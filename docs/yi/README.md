Mobiletto
 =========

 Mobiletto איז אַ דזשאַוואַסקריפּט סטאָרידזש אַבסטראַקשאַן שיכטע, מיט אַפּשאַנאַל טראַנספּעראַנט קליענט-זייַט ענקריפּשאַן.

 # אינהאַלט
 * [פארוואס מאָבילעטטאָ?](#פארוואס-מאָבילעטטאָ?)
 * [שנעל אָנהייב](#קוויק אָנהייב)
 * [מאָבילעטטאָ CLI](#מאָבילעטטאָ-קלי)
 * [מקור](#מקור)
 * [ינסטאַלירונג](#ינסטאַללאַטיאָן)
 * [שטיצן און פאַנדינג](#סופּפּאָרט-און-פאַנדינג)
 * [באַסיק באַניץ](#באַסיק באַניץ)
 * [מעטאַדאַטאַ](# מעטאַדאַטאַ)
 * [אָלטערנאַטיוו אַרייַנפיר נוסח](#אָלטערנאַטיוו-ימפּאָרט-נוסח)
 * [קאַטשינג](# קאַטשינג)
 * [שפּיגל](# מירראָרינג)
 * [טראַנספּאַרענט ענקריפּשאַן](#טראַנספּאַרענט ענקריפּשאַן)
 * [שליסל ראָוטיישאַן](# שליסל ראָוטיישאַן)
 * [דרייווער צובינד](# דרייווער צובינד)
 * [לאָגינג](#לאָגינג)

 # לייענען דעם אין אן אנדער שפּראַך
 דעם README.md דאָקומענט איז איבערגעזעצט, דורך [hokeylization](https://github.com/cobbzilla/hokeylization), אין
 **[יעדער שפּראַך געשטיצט דורך Google Translate](https://cloud.google.com/translate/docs/languages)!**

 איך בין זיכער אַז עס איז נישט גאנץ, אָבער איך האָפֿן עס איז בעסער ווי גאָרנישט!

 [🇸🇦 אַראַביש](../ar/README.md)
 [🇧🇩 בענגאַליש](../bn/README.md)
 [🇩🇪 דייַטש](../de/README.md)
 [🇺🇸 ענגליש](../en/README.md)
 [🇪🇸 שפּאַניש](../es/README.md)
 [🇫🇷 פראנצויזיש](../fr/README.md)
 [🇹🇩 Hausa](../ha/README.md)
 [🇮🇳 הינדיש](../hi/README.md)
 [🇮🇩 אינדאָנעזיש](../id/README.md)
 [🇮🇹 איטאַליעניש](../it/README.md)
 [🇯🇵 יאַפּאַניש](../ja/README.md)
 [🇰🇷 קאָרעיִש](../ko/README.md)
 [🇮🇳 Marathi](../mr/README.md)
 [🇵🇱 פויליש](../pl/README.md)
 [🇧🇷 פּאָרטוגעזיש](../pt/README.md)
 [🇷🇺 רוסיש](../ru/README.md)
 [🇰🇪 סוואַהילי](../sw/README.md)
 [🇵🇭 Tagalog](../tl/README.md)
 [🇹🇷 טערקיש](../tr/README.md)
 [🇵🇰 אורדו](../ur/README.md)
 [🇻🇳 וויעטנאַמעזיש](../vi/README.md)
 [🇨🇳 כינעזיש](../zh/README.md)


 **[📚 ... אַלע שפּראַכן ...](../README.md)**
 ----

 ### איז עס אַ פּראָבלעם מיט דעם איבערזעצונג פון די README?
 די באַזונדער איבערזעצונג פון דער אָריגינעל [README](https://github.com/cobbzilla/mobiletto/blob/master/README.md)
 קען זיין פלאָז - * קערעקשאַנז זענען זייער באַגריסן!* ביטע שיקן אַ [ציען בעטן אויף גיטהוב](https://github.com/cobbzilla/mobiletto/pulls),
 אָדער אויב איר זענט נישט באַקוועם צו טאָן דאָס, [עפענען אַן אַרויסגעבן](https://github.com/cobbzilla/mobiletto/issues)

 ווען איר שאַפֿן אַ נייַע GitHub אַרויסגעבן וועגן אַ איבערזעצונג, ביטע טאָן:
 * אַרייַננעמען די URL פון די בלאַט (קאָפּי / פּאַפּ פון דעם בלעטערער אַדרעס באַר)
 * אַרייַננעמען די פּינטלעך טעקסט וואָס איז פאַלש (קאָפּי / פּאַפּ פון בלעטערער)
 * ביטע באַשרייַבן וואָס איז פאַלש - איז די איבערזעצונג פאַלש? איז די פאָרמאַטטינג עפעס צעבראכן?
 * ביטע פאָרשלאָגן אַ פאָרשלאָג פון אַ בעסער איבערזעצונג, אָדער ווי דער טעקסט זאָל זיין רעכט פאָרמאַטטעד
 * **אדאנק!**

 ## פארוואס מאָבילעטטאָ?

 ### זייַ געזונט פאַרקויפער שלאָס-אין!
 די פאַרשידן וואָלקן סטאָרידזש פּראַוויידערז האָבן ינקאַמפּאַטאַבאַל אַפּיס. אפילו די וואָס שטרעבן פֿאַר "S3 קאַמפּאַטאַבילאַטי"
 האָבן אידיאָסינקראַטיק ביכייוויערז.

 ווען איר קלייַבן אַ באַזונדער סטאָרידזש פאַרקויפער פֿאַר דיין אַפּ, אויב איר קאָד גלייַך צו זייער אַפּי, דיין אַפּ
 איז איצט אָפענגיק אויף דעם דינסט. ווי צייט גייט דורך און קאָד אַקיומיאַלייץ, טשאַנגינג ווענדאָרס ווערט
 ינקריסינגלי אַנטענאַבאַל. ברוכים הבאים צו דער שפּאַס וועלט פון פאַרקויפער שלאָס-אין!

 Mobiletto איז דיזיינד צו סאָלווע דעם פּראָבלעם. דורך קאָודינג דיין אַפּ צו Mobiletto's API, איר קענען לייכט
 טוישן סטאָרידזש פּראַוויידערז און וויסן אַז די סטאָרידזש שיכטע פון דיין אַפּ וועט זיין יידעניקאַל.

 ### ברייטע טעסטינג
 אַלע דריווערס זענען טעסטעד פֿאַר יידעניקאַל נאַטור מיט 60+ טעסץ פֿאַר יעדער שאָפער.
 מיר פּרובירן אַלע דריווערס מיט יעדער קאָמבינאַציע פון:
 * ענקריפּשאַן: ביידע ענייבאַלד און פאַרקריפּלט
 * רעדיס קאַש: ביידע ענייבאַלד און פאַרקריפּלט

 דער צוגאַנג גיט אונדז שלום פון מיינונג אַז מאָבילעטטאָ וועט זיין די זעלבע ראַגאַרדלאַס פון וואָס שאָפער איר נוצן,
 און ראַגאַרדלאַס פון צי איר געבן קאַטשינג און / אָדער ענקריפּשאַן.

 ### דרייווער שטיצן
 קראַנט Mobiletto סטאָרידזש דריווערס:
 * `s3` : Amazon S3
 * `b2` : Backblaze B2
 * `local` : היגע פילעסיסטעם

 * קאַנטריביושאַנז צו שטיצן מער וואָלקן סטאָרידזש פּראַוויידערז זענען זייער באַגריסן!*

 ## מאָבילעטטאָ-קלי
 Mobiletto איז בדעה צו זיין געוויינט ווי אַ ביבליאָטעק דורך אנדערע דזשאַוואַסקריפּט קאָד.

 צו אַרבעטן מיט מאָבילעטטאָ ביי די באַפֿעלן שורה, נוצן [mobiletto-cli](https://www.npmjs.com/package/mobiletto-cli)

 ## מקור
 * [מאָבילעטטאָ אויף גיטהוב](https://github.com/cobbzilla/mobiletto)
 * [מאָבילעטטאָ אויף נפּם](https://www.npmjs.com/package/mobiletto)

 ## שטיצן און פאַנדינג
 איך בין טריינג צו זיין אַ פאַכמאַן אָפֿן מקור ווייכווארג דעוועלאָפּער. איך האב געארבעט אין
 די ווייכווארג אינדוסטריע פֿאַר פילע יאָרן, איך האָבן סטאַרטעד מצליח קאָמפּאַניעס און סאָלד זיי צו ציבור קאָמפּאַניעס.
 לעצטנס איך פאַרפאַלן מיין אַרבעט, און איך טאָן ניט טאַקע האָבן קיין אנדערע אַרבעט ליינד אַרויף

 אַזוי איך וועל פּרובירן צו שרייַבן נוציק ווייכווארג און זען אויב דאָס אַרבעט

 אויב איר הנאה ניצן דעם ווייכווארג, איך וואָלט זיין זייער דאַנקבאַר פֿאַר אפילו די
 קלענסטער [כוידעשלעך צושטייַער דורך Patreon](https://www.patreon.com/cobbzilla)

 *אדאנק!*

 ## ינסטאַלירונג
 ינסטאַלירן מיט `npm` אָדער `yarn` . איר מיסטאָמע ווילן די `lite` ווערסיע וואָס טוט נישט אַרייַננעמען אַלע די
 איבערגעזעצטע README טעקעס:

    npm install mobiletto-lite
    yarn add mobiletto-lite

 אויב איר טאַקע ווילן די README טעקעס אין יעדער שפּראַך, ינסטאַלירן די פול ווערסיע:

    npm install mobiletto
    yarn add mobiletto

 ## שנעל אָנהייב
 א קורץ בייַשפּיל ניצן די Mobiletto `s3` שאָפער.

 דער קאָד וואָלט לויפן די זעלבע אויב דער שאָפער איז געווען `b2` אָדער `local` .

    const storage = require('mobiletto')
    const bucket = await storage.connect('s3', aws_key, aws_secret, {bucket: 'bk'})

    // list objects: returns array of metadata objects
    const listing = await bucket.list()
    const dirList = await bucket.list('some/dir/')
    const everything = await bucket.list('', {recursive: true})

    // write an entire file
    let bytesWritten = await bucket.writeFile('some/path', someBufferOfData)

    // write a file from a stream/generator
    bytesWritten = await bucket.write('some/path', streamOrGenerator)

    // read an entire file
    // returns null if an exception would otherwise be thrown
    const bufferOrNull = await bucket.safeReadFile('some/path')

    // stream-read a file, passing data to callback
    const bytesRead = await bucket.read('some/path', (chunk) => { ...do something with chunk... } )

    // remove a file, returns the path removed
    let removed = await bucket.remove('some/path') // removed is a string

    // remove a directory, returns array of paths removed
    removed = await bucket.remove('some/directory', {recursive: true}) // removed is now an array!

 ----
 ## יקערדיק באַניץ
 א פיל מער ברייט בייַשפּיל, ווייזונג רובֿ פון די פֿעיִקייטן געפֿינט:

    const { mobiletto } = require('mobiletto')

    // General usage
    const api = await mobiletto(driverName, key, secret, opts)

    // To use 'local' driver:
    // * key: base directory
    // * secret: ignored, can be null
    // * opts object:
    // * readOnly: optional, never change anything on the filesystem; default is false
    // * fileMode: optional, permissions used when creating new files, default is 0600. can be string or integer
    // * dirMode: optional, permissions used when creating new directories, default is 0700. can be string or integer
    const local = await mobiletto('local', '/home/ubuntu/tmp', null, {fileMode: 0o0600, dirMode: '0700'})

    // To use 's3' driver:
    // * key: AWS Access Key ID
    // * secret: AWS Secret Key
    // * opts object:
    // * readOnly: optional, never change anything on the bucket; default is false
    // * bucket: required, name of the S3 bucket
    // * region: optional, the AWS region to communicate with, default is us-east-1
    // * prefix: optional, all read/writes within the S3 bucket will be under this prefix
    // * delimiter: optional, directory delimiter, default is '/' (note: always '/' when encryption is enabled)
    const s3 = await mobiletto('s3', aws_key, aws_secret, {bucket: 'bk', region: 'us-east-1'})

    // To use 'b2' driver:
    // * key: Backblaze Key ID
    // * secret: Backblaze Application Key
    // * opts object:
    // * readOnly: optional, never change anything on the bucket; default is false
    // * bucket: required, the ID (**not the name**) of the B2 bucket
    // * prefix: optional, all read/writes within the B2 bucket will be under this prefix
    // * delimiter: optional, directory delimiter, default is '/' (note: always '/' when encryption is enabled)
    // * partSize: optional, large files will be split into chunks of this size when uploading
    const b3 = await mobiletto('b2', b2_key_id, b2_app_key, {bucket: 'bk', partSize: 10000000})

    // List files
    api.list() // --> returns an array of metadata objects

    // List files recursively
    api.list({ recursive: true })

    // List files in a directory
    const path = 'some/path'
    api.list(path)
    api.list(path, { recursive: true }) // also supports recursive flag

    // Visit files in a directory -- visitor function must be async
    api.list(path, { visitor: myAsyncFunc })
    api.list(path, { visitor: myAsyncFunc, recursive: true })

    // The `list` method throws MobilettoNotFoundError if the path does not exist
    // When you call `safeList` on a non-existent path, it returns an empty array
    api.safeList('/path/that/does/not/exist') // returns []
    
    // Read metadata for a file
    api.metadata(path) // returns metadata object

    // The `metadata` method throws MobilettoNotFoundError if the path does not exist
    // When you call `safeMetadata` on a non-existent path, it returns null
    api.safeMetadata('/tmp/does_not_exist') // returns null
    
    // Read a file
    // Provide a callback that writes the data someplace
    const callback = (chunk) => { ... write chunk somewhere ... }
    api.read(path, callback) // returns count of bytes read

    // Read an entire file at once
    const data = await api.readFile(path) // returns a byte Buffer of the file contents
    
    // Read an entire file at once
    // returns null if an exception would otherwise be thrown
    const bufferOrNull = await bucket.safeReadFile('some/path')

    // Write a file
    // Provide a generator function that yields chunks of data
    const generator = function* () {
      while ( ... more-data-to-return ... ) {
        data = ... load-data ...
        yield data
      }
    }
    local.api(path, generator) // returns count of bytes written

    // Write an entire file at once (convenience method)
    await api.writeFile(path, bufferOrString) // returns count of bytes written

    // Delete a file
    // Quiet param is optional (default false), when set errors will not be thrown if the path does not exist
    // Always returns a value or throws an error.
    // Return value may be a single string of the file removed, or an array of all files removed (driver-dependent)
    const quiet = true
    api.remove(path, {quiet}) // returns single path removed

    // Recursively delete a directory and do it quietly (do not report errors)
    const recursive = true
    const quiet = true
    api.remove(path, {recursive, quiet}) // returns array of paths removed

 ## מעטאַדאַטאַ
 די `metadata` באַפֿעל קערט מעטאַדאַטאַ וועגן אַ איין טעקע סיסטעם פּאָזיציע.
 פּונקט אַזוי, דער צוריקקער ווערט פון די `list` באַפֿעל איז אַ מענגע פון מעטאַדאַטאַ אַבדזשעקץ.

 א מעטאַדאַטאַ כייפעץ קוקט ווי דאָס:

    {
      "name": "fully/qualified/path/to/file",
      "type": "entry-type",
      "size": size-in-bytes,
      "ctime": creation-time-epoch-millis,
      "mtime": modification-time-epoch-millis
    }

 די `type` פאַרמאָג קענען זיין `file` , `dir` , `link` אָדער `special` .

 דעפּענדינג אויף דעם טיפּ פון שאָפער, אַ `list` באַפֿעל קען נישט צוריקקומען אַלע פעלדער. די `name` און `type` פּראָפּערטיעס
 זאָל שטענדיק זיין פאָרשטעלן. א סאַבסאַקוואַנט `metadata` באַפֿעל וועט צוריקקומען אַלע בנימצא פּראָפּערטיעס.

 ## אָלטערנאַטיוו אַרייַנפיר נוסח
 אַרייַנפיר די גאָר- `connect` מאָדולע און נוצן די 'פאַרבינדן' פֿונקציע:

    const storage = require('mobiletto')
    const opts = {bucket: 'bk', region: 'us-east-1'}
    const s3 = await storage.connect('s3', aws_key, aws_secret, opts)
    const objectData = await s3.readFile('some/path')

 ## קאַטשינג
 Mobiletto אַרבעט בעסטער מיט אַ <a href="https://redis.io">רעדיס</a> קאַש.

 Mobiletto וועט פּרווון צו פאַרבינדן צו אַ רעדיס בייַשפּיל אויף 127.0.0.1:6379

 איר קענען אָווועררייד איינער פון די:
 * שטעלן די `MOBILETTO_REDIS_HOST` ענוו וואַר, מאָבילעט צו פאַרבינדן דאָ אַנשטאָט פון לאָקאַלהאָסט
 * שטעלן די `MOBILETTO_REDIS_PORT` ענוו וואַר, דעם פּאָרט וועט זיין געוויינט

 Mobiletto וועט קראָם אַלע זיין רעדיס שליסלען מיט די פּרעפיקס `_mobiletto__` . איר קענען טוישן דעם
 דורך באַשטעטיקן די `MOBILETTO_REDIS_PREFIX` env var.

 איר קענען אויך שטעלן פּער-פֿאַרבינדונג קאַטשינג מיט די `opts.redisConfig` כייפעץ:

    const redisConfig = {
        enabled: true, // optional, default is true. if false other props are ignored
        host: '127.0.0.1',
        port: 6379,
        prefix: '_mobiletto__'
    }
    const opts = { redisConfig, bucket: 'bk', region: 'us-east-1' }
    const s3 = await storage.connect('s3', aws_key, aws_secret, opts)

 ### דו זאלסט נישט וועלן רעדיס קאַטשינג?
 צו דיסייבאַל: פאָרן `enabled: false` אין דיין `opts.redisConfig` כייפעץ ווען איר פאַרלייגן דיין קשר.

 ווי דיסקאַסט אונטן, דיסייבאַלינג קאַטשינג וועט האָבן אַ אַדווערס ווירקונג אויף פאָרשטעלונג און האָבן מער ריקוועס
 צו סטאָרידזש אַז איר טאַקע דאַרפֿן צו.

 ### קאַטשינג גיידאַנס
 ** ענקריפּטיד סטאָרידזש **: לייענען / שרייבן ענקריפּטיד סטאָרידזש איז בלויז אַ ביסל סלאָוער ווי נאָרמאַל,
 אָבער נאַוואַגייטינג אַרום דיירעקטעריז (וואָס עטלעכע טינגז טאָן) איז גאַנץ טייַער. ניצן אַ רעדיס קאַש
 וועט געבן איר אַ באַטייטיק פאָרשטעלונג בוסט.

 די פעליקייַט קאַש איז זיכער, אָבער טוט נישט אַרבעטן געזונט אויב איר האָבן אַ פּלאַץ פון שרייַבן / אַראָפּנעמען אַפּעריישאַנז.
 קיין שרייבן אָדער אַראָפּנעמען אָפּעראַציע ינוואַלאַדייץ די גאנצע קאַש, ינשורינג סאַבסאַקוואַנט לייענען וועט זען די
 לעצט ענדערונגען.

 ### CLI מכשירים
 אויב איר נוצן אַ CLI געצייַג ווי [mobiletto-cli](https://www.npmjs.com/package/mobiletto-cli),
 איר וועט באשטימט וועלן די רעדיס קאַש ענייבאַלד, ווייַל עס לאַסץ איבער ינוואַקיישאַנז פון די `mo` באַפֿעל.

 ## שפיגלען

    // Copy a local filesystem mobiletto to S3
    s3.mirror(local)

    // Mirror a local subdirectory from one mobiletto to an S3 mobiletto, with it's own subdirectory
    local.mirror(s3, 'some/local-folder', 'some/s3-folder')

 דער `mirror` באַפֿעל פּערפאָרמז אַ איין מאָל קאָפּיע פון אַלע טעקעס פון איין מאָבילעטטאָ צו אנדערן.
 עס טוט נישט לויפן קיין פּראָצעס צו טייַנען דער שפּיגל איבער צייַט. לויפן די `mirror` באַפֿעל ווידער
 צו סינגקראַנייז קיין פעלנדיק טעקעס.

 דער צוריקקער ווערט פון `mirror` איז אַ פּשוט כייפעץ מיט קאָונטערס פֿאַר ווי פילע טעקעס זענען הצלחה
 מירערד און ווי פילע טעקעס האָבן ערראָרס:

    {
      success: count-of-files-mirrored,
      errors: count-of-files-with-errors
    }

 ווארענונג: מירערינג גרויס דאַטן שטעלט קענען זיין זייער צייט-קאַנסומינג און באַנדווידט-אינטענסיווע

 מיט די `mirror` רופן סעמאַנטיקס עס קען מאל זיין קאַנפיוזינג צו פֿאַרשטיין ווער איז דער
 לייענער און ווער איז דער שרייבער. ימאַדזשאַן עס ווי אַ אַסיינמאַנט ויסזאָגונג: די "לינקס מאָבילעטטאָ"
 איז די זאַך וואָס איז אַסיינד צו (מירערד דאַטן געשריבן), און די "רעכט-האַנט מאָבילעטטאָ" (די
 אַרגומענט צו דער `mirror` אופֿן) איז די ווערט אַסיינד (מירערד דאַטן איז לייענען).

 ## טראַנספּעראַנט ענקריפּשאַן
 געבן טראַנספּעראַנט קליענט-זייַט ענקריפּשאַן:

    // Pass encryption parameters
    const encryption = {
      // key is required, must be >= 16 chars
      key: randomstring.generate(128),

      // optional, the default is to derive IV from key
      // when set, IV must be >= 16 chars
      iv: randomstring.generate(128),

      // optional, the default is aes-256-cbc
      algo: 'aes-256-cbc'
    }
    const api = await mobiletto(driverName, key, secret, opts, encryption)

    // Subsequent write operations will encrypt data (client side) when writing
    // Subsequent read operations will decrypt data (client side) when reading

 וואס טוט זיך? א באַזונדער "דערווייַז פּאָזיציע" (דירענט) וועגווייַזער (ענקריפּטיד) טראַקס וואָס טעקעס זענען אין דעם
 וועגווייַזער (אַקאַ די דירעקט וועגווייַזער).
 * די `list` באַפֿעל לייענט די Directory פּאָזיציע טעקעס, דעקריפּט יעדער דרך ליסטעד; דערנאָך קערט מעטאַדאַטאַ פֿאַר יעדער טעקע
 * `list` קאַמאַנדז זענען מער באַטלאָניש, ספּעציעל פֿאַר דיירעקטעריז מיט אַ גרויס נומער פון טעקעס
 * דער `write` באַפֿעל שרייבט דירעקט טעקעס אין די דירעקט וועגווייַזער פון יעדער פאָטער, רעקורסיוולי; דעמאָלט שרייבט די טעקע
 * `write` קאַמאַנדז וועט מאַכן אָ (ען) שרייבט, מיט N = טיפקייַט אין די וועגווייַזער כייעראַרקי
 * די `remove` באַפֿעל רימוווז די קאָראַספּאַנדינג דירעקט טעקע, און זיין פאָטער אויב ליידיק, רעקורסיוולי; דעמאָלט רימוווז די טעקע
 * ניט-רעקורסיווע `remove` קאַמאַנדז וועט מאַכן אָ (ען) לייענט און פּאַטענטשאַלי ווי פילע דיליץ, מיט N = טיפקייַט אין די וועגווייַזער כייעראַרקי
 * רעקורסיווע `remove` קאַמאַנדז אויף גרויס און טיף פילעסיסטעמס קענען זיין טייַער

 באַמערקונג אַז אפילו מיט ענקריפּשאַן פון קליענט זייַט, אַ קעגנער מיט פול וויזאַביליטי אין דיין ינקריפּטיד סערווער זייַט
 סטאָרידזש, אפילו אָן די שליסל, קענען נאָך זען די גאַנץ נומער פון דירעקטעריז און ווי פילע טעקעס זענען אין יעדער, און מיט
 עטלעכע מי, אַנטדעקן עטלעכע אָדער אַלע פון די קוילעלדיק סטרוקטור פון די וועגווייַזער כייעראַרקי.
 *באַמערקונג: ניצן אַ לעפיערעך פלאַך סטרוקטור פֿאַר בעסער זיכערהייט.*
 דער קעגנער וואָלט נישט וויסן די נעמען פון די דירעקטעריז / טעקעס אויב זיי אויך וויסן דיין ענקריפּשאַן
 שליסל אָדער האט אַנדערש הצלחה קראַקט די ענקריפּשאַן. אַלע בעץ זענען אַוועק דעמאָלט!

 ### פאָרשטעלונג און קאַטשינג
 אָפּעראַטיאָנס אויף ינקריפּטיד סטאָרידזש קענען זיין פּאַמעלעך. רעקורסיווע ליסטינגס און רימווואַלז קענען זיין זייער פּאַמעלעך.
 קאַטשינג דורך רעדיס העלפּס טרימענדאַסלי, אָבער טאָן אַז די קאַש איז פלאַשט אויף קיין שרייבט אָדער רימוווז.

 ## שליסל ראָוטיישאַן
 שאַפֿן אַ מאָבילעטטאָ מיט דיין נייַע שליסל, און שפּיגל די אַלט דאַטן אין עס:

    const storage = require('mobiletto')

    const oldEncryption = { key: .... }
    const oldStorage = await storage.connect('s3', aws_key, aws_secret, {bucket: 'bk', region: 'us-east-1'}, oldEncryption)

    const newEncryption = { key: .... }
    const newStorage = await storage.connect('s3', aws_key, aws_secret, {bucket: 'zz', region: 'us-east-1'}, newEncryption)

    newStorage.mirror(oldStorage) // if oldStorage is very large, this may take a looooooong time...

 ## דרייווער צובינד
 א שאָפער איז קיין JS טעקע וואָס עקספּאָרץ אַ 'סטאָראַגעקליענט' פֿונקציע מיט דעם כסימע:

    function storageClient (key, secret, opts)

 * `key` : אַ שטריקל, דיין אַפּי שליסל (פֿאַר די `local` שאָפער, דאָס איז די באַזע וועגווייַזער)
 * `secret` : אַ שטריקל, דיין אַפּי סוד (קענען זיין איבערגעהיפּערט פֿאַר די `local` דרייווער)
 * `opts` : אַ כייפעץ, די פּראָפּערטיעס זענען פּער שאָפער:
 * פֿאַר `local` , די `fileMode` און `dirMode` פּראָפּערטיעס באַשטימען ווי נייַ קריייטינג טעקעס און דיירעקטעריז זענען באשאפן
 * פֿאַר `s3` , די `bucket` פאַרמאָג איז פארלאנגט. אָפּטיאָנאַל פּראָפּערטיעס זענען:
    * `region`: the S3 region, default is us-east-1
    * `prefix`: a prefix to prepend to all S3 paths, default is the empty string
    * `delimiter`: the directory delimiter, default is '/'

 דער כייפעץ וואָס די storageClient פונקציע קערט מוזן דעפינירן די פאַנגקשאַנז:

    // Test the driver before using, ensure proper configuration
    async testConfig ()

    // List files in path (or from base-directory)
    // If recursive is true, list recursively
    // If visitor is defined, it will be an async function. await the visitor function on each file found
    // Otherwise, perform the listing and return an array of objects
    async list (path, recursive = false, visitor = null) // path may be omitted
    
    // Read metadata for a path
    async metadata (path)
    
    // Read a file
    // callback receives a chunk of data. endCallback is called at end-of-stream
    async read (path, callback, endCallback = null)

    // Write a file
    // driver must be able to handle a generator or a stream
    async write (path, generatorOrReadableStream)

    // Remove a file, or recursively delete a directory
    // returns a string of a single path removed, or an array of multiple paths removed
    async remove (path, recursive = false, quiet = false)

 ## לאָגינג
 Mobiletto ניצט די [winston](https://www.npmjs.com/package/winston) לאָגינג ביבליאָטעק.

 לאָגס **וועט** אַנטהאַלטן טעקע פּאַטס און טעות אַרטיקלען, אָבער וועט **קיינמאָל** אַנטהאַלטן שליסלען, סיקריץ,
 אָדער קיין אנדערע קשר קאַנפיגיעריישאַן אינפֿאָרמאַציע.

 ### קלאָץ מדרגה
 ניצן די `MOBILETTO_LOG_LEVEL` סוויווע בייַטעוודיק צו שטעלן די קלאָץ מדרגה, ניצן איינער
 פון די `npm` לעוועלס דיפיינד אין [https://www.npmjs.com/package/winston#logging-levels](https://www.npmjs.com/package/winston#logging-levels)

 די פעליקייַט מדרגה איז `error` . די מערסט ווערבאָוס מדרגה איז `silly` , כאָטש דערווייַל מאָבילעטטאָ
 טוט נישט קלאָץ אין לעוועלס אונטער `debug`

    MOBILETTO_LOG_LEVEL=silly # maximum logs!

 ### קלאָץ טעקע
 דורך פעליקייַט, די לאָגער שרייבט צו די קאַנסאָול. צו שיקן לאָגס צו אַ טעקע, שטעלן די `MOBILETTO_LOG_FILE`
 סוויווע בייַטעוודיק. ווען לאָגינג צו אַ טעקע, לאָגס וועט ניט מער זיין געשריבן צו די קאַנסאָול.

    MOBILETTO_LOG_FILE=/var/my_mobiletto_log

 צו קער אַוועק לאָגינג:

    MOBILETTO_LOG_FILE=/dev/null

</pre>
